const drawSquircle=(e,t,i,r,s,l)=>{const o=l,h=s/2;e.beginPath(),e.lineTo(i[0],h),e.lineTo(t.width-i[1],h),e.bezierCurveTo(t.width-i[1]/r,h,t.width-h,i[1]/r,t.width-h,i[1]),e.lineTo(t.width-h,t.height-i[2]),e.bezierCurveTo(t.width-h,t.height-i[2]/r,t.width-i[2]/r,t.height-h,t.width-i[2],t.height-h),e.lineTo(i[3],t.height-h),e.bezierCurveTo(i[3]/r,t.height-h,h,t.height-i[3]/r,h,t.height-i[3]),e.lineTo(h,i[0]),e.bezierCurveTo(h,i[0]/r,i[0]/r,h,i[0],h),e.closePath(),s?(e.strokeStyle=o,e.lineWidth=s,e.stroke()):(e.fillStyle=o,e.fill())};if("undefined"!=typeof registerPaint){class e{static get contextOptions(){return{alpha:!0}}static get inputProperties(){return["--squircle-radius","--squircle-radius-top-left","--squircle-radius-top-right","--squircle-radius-bottom-right","--squircle-radius-bottom-left","--squircle-smooth","--squircle-outline","--squircle-fill","--squircle-ratio"]}paint(t,i,r){const s=r.get("--squircle-ratio"),l=parseFloat(s)?parseFloat(s):1.8,o=parseFloat(10*r.get("--squircle-smooth"));let h,a=e.inputProperties.slice(1,5).map((e=>{const t=r.get(e);return t?parseInt(t,10)*l:NaN}));if(a.some(isNaN)){const e=/([0-9]+[a-z%]*)/g,t=r.get("--squircle-radius").toString().match(e);if(t)for(h=t.map((e=>parseInt(e,10)*l));h.length<4;)1===h.length?h.push(h[0]):2===h.length?h=[h[0],h[1],h[0],h[1]]:3===h.length&&(h=[h[0],h[1],h[2],h[1]]);else{const e=a.every(isNaN)?8*l:0;h=[e,e,e,e]}}a=a.map(((e,t)=>isNaN(e)?h[t]:e));const n=parseFloat(r.get("--squircle-outline"),10),u=r.get("--squircle-fill").toString().replace(/\s/g,""),c=()=>void 0!==r.get("--squircle-smooth")[0]?0===o?1:o:10,g=()=>n||0,d=()=>u||"#f45",p=Math.max(...a);if(p<i.width/2&&p<i.height/2)drawSquircle(t,i,a,c(),g(),d());else{const e=Math.min(i.width/2,i.height/2);drawSquircle(t,i,a.map((()=>e)),c(),g(),d())}}}registerPaint("squircle",e)}